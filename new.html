<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href='https://fonts.googleapis.com/css?family=Poppins' rel='stylesheet'>
    <title>Skill Sync</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
   <style>
    
body {
    font-family: 'Poppins';font-size: 22px;
    background-color: #19223d;
    margin: 20px;
    padding: 0;
    color: #cccfdb;
}
/* Navbar style */
.navbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px 40px;
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    position: fixed;
    width: 100%;
    top: 0;
    left: 0;
    z-index: 100;
}

.navbar a {
    color: white;
    text-decoration: none;
    margin: 0 20px;
    font-size: 18px;
    font-weight: bold;
    transition: 0.3s ease;
}

.navbar a:hover {
    color: #0095ff;
}

.navbar .logo {
    font-size: 24px;
    font-weight: bold;
    color: #ffffff;
}

/* Navbar menu toggle (for mobile) */
.menu-toggle {
    display: none;
    cursor: pointer;
    color: white;
}

.menu-toggle svg {
    width: 24px;
    height: 24px;
}

.navbar-links {
    display: flex;
}

@media (max-width: 768px) {
    .menu-toggle {
        display: block;
    }

    .navbar-links {
        display: none;
        width: 100%;
        flex-direction: column;
        align-items: center;
        background: rgba(0, 0, 0, 0.5);
        position: absolute;
        top: 70px;
        left: 0;
        padding: 20px;
        border-radius: 10px;
        z-index: 99;
    }

    .navbar-links.active {
        display: flex;
    }

    .navbar-links a {
        margin: 15px 0;
    }
}

input{
    font-family: 'Poppins';font-size: 22px;
    color: #ede5e5;
}

#container {
    display: flex;
    flex-direction: column;
    padding: 80px 20px 20px; /* Add padding on top to prevent overlap */
    margin-top: 70px; 
    margin: 0 auto;
    width: 80%;
    max-width: 1200px;
}

h1 {
    font-size: 11vh;
    text-align: center;
    color: #fcfafa;
}

input {
    width: 100%;
    padding: 10px;
    font-size: 16px;
    margin: 10px 0;
    background-color: #1e2948;
}

#roadmap {
    width: 100vh;
    height: 100vh;
    border: 1px ;
}

/* Loader Spinner */
/* From Uiverse.io by Nawsome */ 
.loadingspinner {
--square: 26px;
--offset: 30px;
--duration: 2.4s;
--delay: 0.2s;
--timing-function: ease-in-out;
--in-duration: 0.4s;
--in-delay: 0.1s;
--in-timing-function: ease-out;
width: calc( 3 * var(--offset) + var(--square));
height: calc( 2 * var(--offset) + var(--square));
padding: 0px;
margin-left: auto;
margin-right: auto;
margin-top: 10px;
margin-bottom: 30px;
position: relative;
}

.loadingspinner div {
display: inline-block;
opacity: 77%;
background: rgb(63, 85, 213);
/*background: var(--text-color);*/
/*box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.4);*/
border: none;
border-radius: 2px;
width: var(--square);
height: var(--square);
position: absolute;
padding: 0px;
margin: 0px;
font-size: 6pt;
color: black;
}

.loadingspinner #square1 {
left: calc( 0 * var(--offset) );
top: calc( 0 * var(--offset) );
animation: square1 var(--duration) var(--delay) var(--timing-function) infinite,
       squarefadein var(--in-duration) calc(1 * var(--in-delay)) var(--in-timing-function) both;
}

.loadingspinner #square2 {
left: calc( 0 * var(--offset) );
top: calc( 1 * var(--offset) );
animation: square2 var(--duration) var(--delay) var(--timing-function) infinite,
      squarefadein var(--in-duration) calc(1 * var(--in-delay)) var(--in-timing-function) both;
}

.loadingspinner #square3 {
left: calc( 1 * var(--offset) );
top: calc( 1 * var(--offset) );
animation: square3 var(--duration) var(--delay) var(--timing-function) infinite,
       squarefadein var(--in-duration) calc(2 * var(--in-delay)) var(--in-timing-function) both;
}

.loadingspinner #square4 {
left: calc( 2 * var(--offset) );
top: calc( 1 * var(--offset) );
animation: square4 var(--duration) var(--delay) var(--timing-function) infinite,
       squarefadein var(--in-duration) calc(3 * var(--in-delay)) var(--in-timing-function) both;
}

.loadingspinner #square5 {
left: calc( 3 * var(--offset) );
top: calc( 1 * var(--offset) );
animation: square5 var(--duration) var(--delay) var(--timing-function) infinite,
       squarefadein var(--in-duration) calc(4 * var(--in-delay)) var(--in-timing-function) both;
}

@keyframes square1 {
0% {
left: calc( 0 * var(--offset) );
top: calc( 0 * var(--offset) );
}

8.333% {
left: calc( 0 * var(--offset) );
top: calc( 1 * var(--offset) );
}

100% {
left: calc( 0 * var(--offset) );
top: calc( 1 * var(--offset) );
}
}

@keyframes square2 {
0% {
left: calc( 0 * var(--offset) );
top: calc( 1 * var(--offset) );
}

8.333% {
left: calc( 0 * var(--offset) );
top: calc( 2 * var(--offset) );
}

16.67% {
left: calc( 1 * var(--offset) );
top: calc( 2 * var(--offset) );
}

25.00% {
left: calc( 1 * var(--offset) );
top: calc( 1 * var(--offset) );
}

83.33% {
left: calc( 1 * var(--offset) );
top: calc( 1 * var(--offset) );
}

91.67% {
left: calc( 1 * var(--offset) );
top: calc( 0 * var(--offset) );
}

100% {
left: calc( 0 * var(--offset) );
top: calc( 0 * var(--offset) );
}
}

@keyframes square3 {
0%,100% {
left: calc( 1 * var(--offset) );
top: calc( 1 * var(--offset) );
}

16.67% {
left: calc( 1 * var(--offset) );
top: calc( 1 * var(--offset) );
}

25.00% {
left: calc( 1 * var(--offset) );
top: calc( 0 * var(--offset) );
}

33.33% {
left: calc( 2 * var(--offset) );
top: calc( 0 * var(--offset) );
}

41.67% {
left: calc( 2 * var(--offset) );
top: calc( 1 * var(--offset) );
}

66.67% {
left: calc( 2 * var(--offset) );
top: calc( 1 * var(--offset) );
}

75.00% {
left: calc( 2 * var(--offset) );
top: calc( 2 * var(--offset) );
}

83.33% {
left: calc( 1 * var(--offset) );
top: calc( 2 * var(--offset) );
}

91.67% {
left: calc( 1 * var(--offset) );
top: calc( 1 * var(--offset) );
}
}

@keyframes square4 {
0% {
left: calc( 2 * var(--offset) );
top: calc( 1 * var(--offset) );
}

33.33% {
left: calc( 2 * var(--offset) );
top: calc( 1 * var(--offset) );
}

41.67% {
left: calc( 2 * var(--offset) );
top: calc( 2 * var(--offset) );
}

50.00% {
left: calc( 3 * var(--offset) );
top: calc( 2 * var(--offset) );
}

58.33% {
left: calc( 3 * var(--offset) );
top: calc( 1 * var(--offset) );
}

100% {
left: calc( 3 * var(--offset) );
top: calc( 1 * var(--offset) );
}
}

@keyframes square5 {
0% {
left: calc( 3 * var(--offset) );
top: calc( 1 * var(--offset) );
}

50.00% {
left: calc( 3 * var(--offset) );
top: calc( 1 * var(--offset) );
}

58.33% {
left: calc( 3 * var(--offset) );
top: calc( 0 * var(--offset) );
}

66.67% {
left: calc( 2 * var(--offset) );
top: calc( 0 * var(--offset) );
}

75.00% {
left: calc( 2 * var(--offset) );
top: calc( 1 * var(--offset) );
}

100% {
left: calc( 2 * var(--offset) );
top: calc( 1 * var(--offset) );
}
}

@keyframes squarefadein {
0% {
transform: scale(0.75);
opacity: 0.0;
}

100% {
transform: scale(1.0);
opacity: 1.0;
}
}

/* Animation */
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.node circle {
    fill: rgb(69, 48, 85);
    stroke: #25335c;
    stroke-width: 1.5px;
}

.node text {
    font-size: 10px;
    fill: #ede5e5;
}

.link {
    fill: none;
    stroke: #1d2c5a;
    stroke-width: 2px;
}
.checkbox-wrapper-4 * {
box-sizing: border-box;
}
.checkbox-wrapper-4 .cbx {
-webkit-user-select: none;
user-select: none;
cursor: pointer;
padding: 6px 8px;
border-radius: 6px;
overflow: hidden;
transition: all 0.2s ease;
display: inline-block;
}
.checkbox-wrapper-4 .cbx:not(:last-child) {
margin-right: 6px;
}
.checkbox-wrapper-4 .cbx:hover {
background: rgba(0,119,255,0.06);
}
.checkbox-wrapper-4 .cbx span {
float: left;
vertical-align: middle;
transform: translate3d(0, 0, 0);
}
.checkbox-wrapper-4 .cbx span:first-child {
position: relative;
width: 18px;
height: 18px;
border-radius: 4px;
transform: scale(1);
border: 1px solid #cccfdb;
transition: all 0.2s ease;
box-shadow: 0 1px 1px rgba(0,16,75,0.05);
}
.checkbox-wrapper-4 .cbx span:first-child svg {
position: absolute;
top: 3px;
left: 2px;
fill: none;
stroke: #fff;
stroke-width: 2;
stroke-linecap: round;
stroke-linejoin: round;
stroke-dasharray: 16px;
stroke-dashoffset: 16px;
transition: all 0.3s ease;
transition-delay: 0.1s;
transform: translate3d(0, 0, 0);
}
.checkbox-wrapper-4 .cbx span:last-child {
padding-left: 8px;
line-height: 18px;
}
.checkbox-wrapper-4 .cbx:hover span:first-child {
border-color: #07f;
}
.checkbox-wrapper-4 .inp-cbx {
position: absolute;
visibility: hidden;
}
.checkbox-wrapper-4 .inp-cbx:checked + .cbx span:first-child {
background: #07f;
border-color: #07f;
animation: wave-4 0.4s ease;
}
.checkbox-wrapper-4 .inp-cbx:checked + .cbx span:first-child svg {
stroke-dashoffset: 0;
}
.checkbox-wrapper-4 .inline-svg {
position: absolute;
width: 0;
height: 0;
pointer-events: none;
user-select: none;
}
@media screen and (max-width: 640px) {
.checkbox-wrapper-4 .cbx {
width: 100%;
display: inline-block;
}
}
@-moz-keyframes wave-4 {
50% {
transform: scale(0.9);
}
}
@-webkit-keyframes wave-4 {
50% {
transform: scale(0.9);
}
}
@-o-keyframes wave-4 {
50% {
transform: scale(0.9);
}
}
@keyframes wave-4 {
50% {
transform: scale(0.9);
}
}
.button {

--bezier: cubic-bezier(0.22, 0.61, 0.36, 1);
--edge-light: hsla(0, 0%, 50%, 0.8);
--text-light: rgba(255, 255, 255, 0.4);
--back-color: 240, 40%;
font-family: 'Poppins';font-size: 22px;
cursor: pointer;
padding: 0.7em 1em;
border-radius: 0.5em;
min-height: 2.4em;
min-width: 3em;
display: block;
align-items: center;
gap: 0.5em;
max-width: fit-content;

font-size: 18px;
letter-spacing: 0.02em;
line-height: 1;

background: linear-gradient(
140deg,
hsla(var(--back-color), 50%, 1) min(2em, 20%),
hsla(var(--back-color), 50%, 0.6) min(8em, 100%)
);
color: hsla(0, 0%, 90%);
border: 0;
box-shadow: inset 0.4px 1px 4px var(--edge-light);

transition: all 0.1s var(--bezier);
}

.button:hover {
--edge-light: hsla(0, 0%, 50%, 1);
text-shadow: 0px 0px 10px var(--text-light);
box-shadow: inset 0.4px 1px 4px var(--edge-light),
2px 4px 8px hsla(0, 0%, 0%, 0.295);
transform: scale(1.1);
}

.button:active {
--text-light: rgba(255, 255, 255, 1);

background: linear-gradient(
140deg,
hsla(var(--back-color), 50%, 1) min(2em, 20%),
hsla(var(--back-color), 50%, 0.6) min(8em, 100%)
);
box-shadow: inset 0.4px 1px 8px var(--edge-light),
0px 0px 8px hsla(var(--back-color), 50%, 0.6);
text-shadow: 0px 0px 20px var(--text-light);
color: hsla(0, 0%, 100%, 1);
letter-spacing: 0.1em;
transform: scale(1);
}
   </style>
</head>
<body>
    <div class="navbar">
        <div class="logo">Skill Sync</div>
        <div class="navbar-links">
            <a href="#">Home</a>
            <a href="#">Features</a>
            <a href="#">About</a>
            <a href="#">Contact</a>
        </div>
        <div class="menu-toggle" onclick="toggleMenu()">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill="currentColor" d="M3 6h18M3 12h18M3 18h18"></path>
            </svg>
        </div>
    </div>
<div id="container">
    <h1>Skill Sync</h1>
    <input type="text" id="topic" placeholder="Enter a topic to learn (e.g., Machine Learning)">

    <!-- Subject Checkbox -->
    <div class="checkbox-wrapper-4">
        <input type="checkbox" id="subject-checkbox" class="inp-cbx" />
        <label for="subject-checkbox" class="cbx">
          <span>
            <svg width="12px" height="10px" viewBox="0 0 12 10">
              <polyline points="1.5 6 4.5 9 10.5 1"></polyline>
            </svg>
          </span>
          <span>Is this for a subject?</span>
        </label>
      </div>
      
    <!-- Subject input (shown if checkbox is checked) -->
    <div id="subject-input" style="display: none;">
        <input type="text" id="subject" placeholder="Enter the subject (e.g., Math)">
    </div>

        <div class="checkbox-wrapper-4">
            <input type="checkbox" id="carrer-checkbox" class="inp-cbx" />
            <label for="carrer-checkbox" class="cbx">
              <span>
                <svg width="12px" height="10px" viewBox="0 0 12 10">
                  <polyline points="1.5 6 4.5 9 10.5 1"></polyline>
                </svg>
              </span>
              <span>Is this a part of your carrer?</span>
            </label>
          </div>

    <div id="carrer-input" style="display: none;">
     <input type="text" id="career-plan" placeholder="Enter your career plan (e.g., Become a Data Scientist)">
    </div>
    <input type="text" id="topic1" style="display: none;">

    <!-- Career Plan input -->

    <center><button class="button" onclick="generateRoadmap()">
        <svg
        viewBox="0 0 16 16"
        class="bi bi-lightning-charge-fill"
        fill="currentColor"
        height="16"
        width="16"
        xmlns="http://www.w3.org/2000/svg">
        <path
          d="M11.251.068a.5.5 0 0 1 .227.58L9.677 6.5H13a.5.5 0 0 1 .364.843l-8 8.5a.5.5 0 0 1-.842-.49L6.323 9.5H3a.5.5 0 0 1-.364-.843l8-8.5a.5.5 0 0 1 .615-.09z"
        ></path></svg>Generate Roadmap</button></center>

    <!-- Loader animation -->
    <div id="loader" class="loadingspinner" style="display:none;"><div id="square1"></div>
    <div id="square2"></div>
    <div id="square3"></div>
    <div id="square4"></div>
    <div id="square5"></div></div>

    <div id="roadmap"></div>
</div>

<footer>
    <p>&copy; 2025 Skill Sync. Made By Students , For the Students.</p>
</footer>

<script>
    // Show or hide subject input based on checkbox
    document.getElementById('subject-checkbox').addEventListener('change', function() {
        const subjectInput = document.getElementById('subject-input');
        if (this.checked) {
            subjectInput.style.display = 'block';
        } else {
            subjectInput.style.display = 'none';
        }
    });
    document.getElementById('carrer-checkbox').addEventListener('change', function() {
        const subjectInput = document.getElementById('carrer-input');
        if (this.checked) {
            subjectInput.style.display = 'block';
        } else {
            subjectInput.style.display = 'none';
        }
    });
        const topic = document.getElementById('topic').value;
        const subject = document.getElementById('subject').value;
        const careerPlan = document.getElementById('career-plan').value;
        let prompt = `Given topic: "${topic}".`;

        if (subject) {
            prompt += ` and the subject is: "${subject}".`;
        }

        if (careerPlan) {
            prompt += ` The career plan is: "${careerPlan}".`;
        }

        document.getElementById('topic1').value = prompt;
</script>
<script>async function generateRoadmap() {
    const topic = document.getElementById('topic1').value;
    if (!topic) {
      alert("Please enter a topic.");
      return;
    }
  
    // Call the Cohere API to generate the roadmap (with your API key)
    const roadmapText = await fetchRoadmap(topic);
  
    // Parse the roadmap
    const parsedRoadmap = parseRoadmap(roadmapText);
  
    // Render the roadmap as a tree
    renderRoadmap(parsedRoadmap);
  }
  
  // API request to Cohere for generating the roadmap
  async function fetchRoadmap(topic) {
    const apiKey = 'G5G7vMkCgkHCeq8BKvrk4MUVVpi8ErbUPSuua203';  // Replace with your Cohere API key
    const endpoint = 'https://api.cohere.ai/v1/generate';  // Cohere API endpoint
  
    const prompt = `
      Generate a detailed roadmap for learning the topic: "${topic}". Use the following format:
      - Each topic or subtopic must start with a "|".
      - Indent subtopics by adding more "|" (e.g., "||" for level 2, "|||" for level 3) dont use ':' or things like that here.
      - Use "->" to show relationships or connections between topics and subtopics (e.g., "Topic A -> Subtopic A1").
  
      Example format:
      | Topic A
      || Subtopic A1
      || Subtopic A2 -> Subtopic A3
      | Topic B
      || Subtopic B1
      || Subtopic B1.1
      ||| Sub-subtopic B1.2 -> Sub-subtopic B1.3
      | Topic C
      || Subtopic C1 -> Subtopic C2
      ||| Sub-subtopic C1.2 -> Sub-subtopic C1.3
  
      Generate the roadmap with the structure as above.`;
  
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: 'command-xlarge-nightly',  // Choose the appropriate model; you can try other options like 'large', 'medium', etc.
        prompt: prompt,
        max_tokens: 500,  // Adjust as needed
        temperature: 0.7,  // You can play with the temperature for more creative results
        top_p: 1.0,
        frequency_penalty: 0.0,
        presence_penalty: 0.0,
      })
    });
  
    const data = await response.json();
  
    if (data && data.generations && data.generations[0]) {
      return data.generations[0].text.trim();
    } else {
      console.error("Error generating roadmap");
      return '';
    }
  }
  
  // Parse the roadmap string into a tree structure
  function parseRoadmap(text, topic) {
    const lines = text.trim().split("\n");
    const tree = { name: topic, children: [] };  // Set the root node to the user-provided topic
    const nodeMap = { [topic]: tree };
  
    lines.forEach((line) => {
      const level = line.match(/^\|+/)[0].length;
      const content = line.replace(/^\|+/, "").trim();
      const [name, connections] = content.split("->").map(s => s.trim());
  
      const node = { name, children: [] };
      if (level === 1) {
        tree.children.push(node);
      } else {
        const parent = nodeMap[Object.keys(nodeMap).reverse().find((key) => key.startsWith(level - 1))];
        if (parent) parent.children.push(node);
      }
  
      nodeMap[`${level}:${name}`] = node;
  
      if (connections) {
        connections.split(",").forEach((target) => {
          const targetNode = nodeMap[Object.keys(nodeMap).find((key) => key.endsWith(target.trim()))];
          if (targetNode) {
            node.children.push({ name: target.trim(), isReference: true });
          }
        });
      }
    });
  
    return tree;
  }
  async function generateRoadmap() {
    const topic = document.getElementById('topic').value;
    if (!topic) {
      alert("Please enter a topic.");
      return;
    }
  
    // Show the loader
    document.getElementById('loader').style.display = 'block';
    // Call the Cohere API to generate the roadmap (with your API key)
    const roadmapText = await fetchRoadmap(topic);
  
    // Parse the roadmap, passing the topic to set as the root node name
    const parsedRoadmap = parseRoadmap(roadmapText, topic);
  
    // Render the roadmap as a tree
    renderRoadmap(parsedRoadmap);
  
    document.getElementById('loader').style.display = 'none';
  }
  
  function renderRoadmap(data) {
    const margin = { top: 10, right: 120, bottom: 10, left: 120 };
    const width = Math.max(960, window.innerWidth - margin.left - margin.right);
    let height = Math.max(600, Math.min(window.innerHeight * 0.8, 1000));
  
    const svg = d3.select("#roadmap").append("svg")
      .attr("width", width + margin.right + margin.left)
      .attr("height", height + margin.top + margin.bottom);
  
    const rootGroup = svg.append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
  
    const root = d3.hierarchy(data);
  
    // Set a larger node separation to avoid overlapping
    const treeLayout = d3.tree().nodeSize([50, 200]); // [vertical spacing, horizontal spacing]
    treeLayout(root);
  
    // Add zoom behavior
    const zoom = d3.zoom()
      .scaleExtent([0.1, 3])  // Set min and max zoom scale
      .on("zoom", function(event) {
        rootGroup.attr("transform", event.transform); // Apply the zoom and pan transformation to the root group
      });
  
    // Apply zoom behavior to the SVG container
    svg.call(zoom);
  
    // Links
    rootGroup.selectAll(".link")
      .data(root.links())
      .enter().append("path")
      .attr("class", "link")
      .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x))
      .attr("fill", "none")
      .attr("stroke", "#ccc")
      .attr("stroke-width", 1.5);
  
    // Nodes
    const nodes = rootGroup.selectAll(".node")
      .data(root.descendants())
      .enter().append("g")
      .attr("class", "node")
      .attr("transform", d => "translate(" + d.y + "," + d.x + ")");
  
    // Rounded rectangles
    nodes.append("rect")
      .attr("x", d => -getTextWidth(d.data.name) / 2 - 10) // Center the rectangle
      .attr("y", -15) // Align vertically
      .attr("width", d => getTextWidth(d.data.name) + 20) // Adjust width based on text
      .attr("height", 30) // Fixed height
      .attr("rx", 10) // Rounded corners
      .attr("ry", 10)
      .style("fill", "#1b2141")
      .style("stroke", "#0b4564")
      .style("stroke-width", 1.5);
  
    // Text inside the rectangles
    nodes.append("text")
      .attr("dy", 5) // Center the text vertically
      .attr("text-anchor", "middle")
      .style("font-size", "12px")
      .text(d => d.data.name);
  
    // Dynamically adjust page size based on the tree size
    adjustPageSize(width, height);
  }
  
  
  // Helper function to calculate the text width
  function getTextWidth(text) {
    const context = document.createElement("canvas").getContext("2d");
    context.font = "12px sans-serif"; // Match the font style of the text
    return context.measureText(text).width;
  }
  
  // Dynamically adjust page size to fit the tree
  function adjustPageSize(treeWidth, treeHeight) {
    const margin = { top: 10, right: 120, bottom: 10, left: 120 };
  
    // Adjust the body size based on the tree's dimensions
    document.body.style.height = `${treeHeight + margin.top + margin.bottom}px`;
    document.body.style.width = `${treeWidth + margin.left + margin.right}px`;
  
    // Adjust the SVG size
    d3.select("svg")
      .attr("width", treeWidth + margin.left + margin.right)
      .attr("height", treeHeight + margin.top + margin.bottom);
  }
  
  
  // Helper function for text wrapping
  function wrapText(text, width) {
    text.each(function () {
      const text = d3.select(this);
      const words = text.text().split(/\s+/).reverse();
      let word, line = [], lineNumber = 0, lineHeight = 1.1; // Line height in ems
      const x = text.attr("x") || 0, y = text.attr("y") || 0;
      const dy = parseFloat(text.attr("dy")) || 0;
  
      let tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", `${dy}em`);
  
      while ((word = words.pop())) {
        line.push(word);
        tspan.text(line.join(" "));
        if (tspan.node().getComputedTextLength() > width) {
          line.pop();
          tspan.text(line.join(" "));
          line = [word];
          tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", `${++lineNumber * lineHeight + dy}em`).text(word);
        }
      }
    });
  }
  </script>

</body>
</html>
